Festive Marmalade Unicorn

High

# Rounding errors in the calculation of `variableToWithdrawnStakingEarningsInShares` will lead to lack of ethers in the vault

### Summary

In the calculation of `variableToWithdrawnStakingEarningsInShares`, rounding down is used instead of rounding up. So, the lack of dust ether may result in that the last user of the vault cannot withdraw his fund. 

### Root Cause

In LidoVault.sol:783, the calculation of `variableToWithdrawnStakingEarningsInShares` should use rounding up rather than rounding down.

https://github.com/sherlock-audit/2024-08-saffron-finance/blob/main/lido-fiv/contracts/LidoVault.sol#L775-L785
```solidity
      uint256 totalEarnings = vaultEndingETHBalance.mulDiv(withdrawnStakingEarningsInStakes,vaultEndingStakesAmount) - totalProtocolFee  + vaultEndedStakingEarnings;

      if (totalEarnings > 0) {
        (uint256 currentState, uint256 stakingEarningsShare) = calculateVariableWithdrawState(
          totalEarnings,
@>        variableToWithdrawnStakingEarningsInShares[msg.sender].mulDiv(vaultEndingETHBalance, vaultEndingStakesAmount)
        );
        stakingShareAmount = stakingEarningsShare;
@>      variableToWithdrawnStakingEarningsInShares[msg.sender] = currentState.mulDiv(vaultEndingStakesAmount,vaultEndingETHBalance);
        variableToWithdrawnStakingEarnings[msg.sender] = currentState;
      }
```

It is possible for some variable users to permanently withdraw dust amounts generated by rounding errors.
https://github.com/sherlock-audit/2024-08-saffron-finance/blob/main/lido-fiv/contracts/LidoVault.sol#L859-L874
```solidity
  function calculateVariableWithdrawState(
    uint256 totalEarnings,
    uint256 previousWithdrawnAmount
  ) internal view returns (uint256, uint256) {

    uint256 bearerBalance = variableBearerToken[msg.sender];
    require(bearerBalance > 0, "NBT");

    uint256 totalOwed = bearerBalance.mulDiv(totalEarnings, variableSideCapacity);
    uint256 ethAmountOwed = 0;
    if (previousWithdrawnAmount < totalOwed) {
@>    ethAmountOwed = totalOwed - previousWithdrawnAmount;
    }

    return (ethAmountOwed + previousWithdrawnAmount, ethAmountOwed);
  }
```
As a result, the lack of sufficient dust Ether may prevent the last user of the vault from successfully withdrawing their funds.

### Internal pre-conditions

Assume the following condition:
  totalEarnings = 10000
  vaultEndingETHBalance = 123
  vaultEndingStakesAmount = 97
  variableSideCapacity = 1000

### External pre-conditions

_No response_

### Attack Path

Assume that:
  variableBearerToken[Alice] = 170
Then,
  currentState = 10000 * 170 / 1000 = 1700
  currentState.mulDiv(vaultEndingStakesAmount,vaultEndingETHBalance) = 1700 * 97 /123 = 1340
  variableToWithdrawnStakingEarningsInShares[msg.sender].mulDiv(vaultEndingETHBalance, vaultEndingStakesAmount) = 1340 * 123 / 97 = 1699

It means that Alice can always 1700 - 1699 = 1wei forever. As a result, the last user may be unable to withdraw their funds due to a lack of sufficient dust amounts.

Even in the absence of malicious users, this situation can still occur.

### Impact

The last user of the vault cannot withdraw his fund. 

### PoC

_No response_

### Mitigation

```solidity
          (, uint256 ethAmountOwed) = calculateVariableWithdrawState(
            (lidoStETHBalance.mulDiv(currentStakes + withdrawnStakingEarningsInStakes, currentStakes) - fixedETHDeposits),
-           variableToWithdrawnStakingEarningsInShares[msg.sender].mulDiv(lidoStETHBalance, currentStakes)
+           variableToWithdrawnStakingEarningsInShares[msg.sender].mulDiv(lidoStETHBalance, currentStakes, Rounding.Up)
          );
```

https://github.com/sherlock-audit/2024-08-saffron-finance/blob/main/lido-fiv/contracts/LidoVault.sol#L775-L785
```diff
      uint256 totalEarnings = vaultEndingETHBalance.mulDiv(withdrawnStakingEarningsInStakes,vaultEndingStakesAmount) - totalProtocolFee  + vaultEndedStakingEarnings;

      if (totalEarnings > 0) {
        (uint256 currentState, uint256 stakingEarningsShare) = calculateVariableWithdrawState(
          totalEarnings,
-         variableToWithdrawnStakingEarningsInShares[msg.sender].mulDiv(vaultEndingETHBalance, vaultEndingStakesAmount)
+         variableToWithdrawnStakingEarningsInShares[msg.sender].mulDiv(vaultEndingETHBalance, vaultEndingStakesAmount,Rounding.Up)
        );
        stakingShareAmount = stakingEarningsShare;
-       variableToWithdrawnStakingEarningsInShares[msg.sender] = currentState.mulDiv(vaultEndingStakesAmount,vaultEndingETHBalance);
+       variableToWithdrawnStakingEarningsInShares[msg.sender] = currentState.mulDiv(vaultEndingStakesAmount,vaultEndingETHBalance, Rounding.Up);
        variableToWithdrawnStakingEarnings[msg.sender] = currentState;
      }
```